16
{"last_modification_time":1565438549,"language":1,"import_file":"c:/users/udit6/desktop/vex/v5tester/include/common/set.h","args_hash":1876850506571660888,"includes":[],"dependencies":["c:/users/udit6/desktop/vex/v5tester/include/common/set.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/lib/gcc/arm-none-eabi/7.2.1/include/stdint.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/stdint.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/machine/_default_types.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/features.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/_intsup.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/_stdint.h","c:/users/udit6/desktop/vex/v5tester/include/kapi.h","c:/users/udit6/desktop/vex/v5tester/include/api.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cerrno","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/c++config.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/errno.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/errno.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/reent.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/_ansi.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/newlib.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/config.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/_types.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/machine/_types.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/lock.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cmath","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/cpp_type_traits.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/ext/type_traits.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/math.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/cdefs.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/std_abs.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/stdlib.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/alloca.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/specfun.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/stl_algobase.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/functexcept.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/ext/numeric_traits.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/stl_pair.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/move.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/concept_check.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/type_traits","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/stl_iterator_base_types.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/stl_iterator_base_funcs.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/stl_iterator.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/ptr_traits.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/debug/debug.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/limits","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/gamma.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/bessel_function.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/exp_integral.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/legendre_function.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/modified_bessel_func.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/riemann_zeta.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cstdbool","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cstddef","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cstdint","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cstdio","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/stdio.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/types.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/machine/endian.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/select.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/_timeval.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/timespec.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/_timespec.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/_pthreadtypes.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/sched.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/stdio.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cstdlib","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/iostream","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/ostream","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/ios","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/iosfwd","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/stringfwd.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/memoryfwd.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/postypes.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cwchar","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/wchar.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/xlocale.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/exception","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/exception.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/exception_ptr.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/cxxabi_init_exception.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/typeinfo","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/hash_bytes.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/new","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/nested_exception.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/char_traits.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/localefwd.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/c++locale.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/clocale","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/locale.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cctype","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/ctype.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/ios_base.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/ext/atomicity.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/gthr.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/locale_classes.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/string","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/allocator.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/c++allocator.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/ext/new_allocator.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/ostream_insert.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/stl_function.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/range_access.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/initializer_list","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/basic_string.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/ext/alloc_traits.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/alloc_traits.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/string_view","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/functional_hash.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/ext/string_conversions.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/basic_string.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/system_error","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/error_constants.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/stdexcept","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/streambuf","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/basic_ios.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/locale_facets.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/cwctype","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/wctype.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/streambuf_iterator.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/ostream.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/istream","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/istream.tcc","c:/users/udit6/desktop/vex/v5tester/include/pros/adi.h","c:/users/udit6/desktop/vex/v5tester/include/pros/llemu.h","c:/users/udit6/desktop/vex/v5tester/include/display/lvgl.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_task.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_ll.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_mem.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_hal/lv_hal.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_hal/lv_hal_disp.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_color.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_hal/lv_hal_indev.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_area.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/string.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/strings.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_hal/lv_hal_tick.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_core/lv_group.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_core/lv_obj.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_core/lv_style.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_anim.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_font.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_fonts/lv_symbol_def.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_core/lv_vdb.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_themes/lv_theme.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_themes/lv_theme_alien.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_bar.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_btn.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_core/lv_indev.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_cont.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_label.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_txt.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_btnm.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_cb.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_chart.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_line.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_ddlist.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_page.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_gauge.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_lmeter.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_img.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_draw/lv_draw.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_misc/lv_fs.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_kb.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_led.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_list.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_mbox.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_roller.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_slider.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_sw.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_ta.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_tabview.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_objx/lv_win.h","c:/users/udit6/desktop/vex/v5tester/include/pros/misc.h","c:/users/udit6/desktop/vex/v5tester/include/pros/motors.h","c:/users/udit6/desktop/vex/v5tester/include/pros/rtos.h","c:/users/udit6/desktop/vex/v5tester/include/pros/vision.h","c:/users/udit6/desktop/vex/v5tester/include/pros/adi.hpp","c:/users/udit6/desktop/vex/v5tester/include/pros/llemu.hpp","c:/users/udit6/desktop/vex/v5tester/include/pros/misc.hpp","c:/users/udit6/desktop/vex/v5tester/include/pros/motors.hpp","c:/users/udit6/desktop/vex/v5tester/include/pros/rtos.hpp","c:/users/udit6/desktop/vex/v5tester/include/pros/vision.hpp","c:/users/udit6/desktop/vex/v5tester/include/pros/apix.h","c:/users/udit6/desktop/vex/v5tester/include/pros/serial.h","c:/users/udit6/desktop/vex/v5tester/include/pros/serial.hpp","c:/users/udit6/desktop/vex/v5tester/include/rtos/freertos.h","c:/users/udit6/desktop/vex/v5tester/include/rtos/freertosconfig.h","c:/users/udit6/desktop/vex/v5tester/include/rtos/portable.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/reent.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/predefined_ops.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/special_function_util.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/beta_function.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/ell_integral.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/hypergeometric.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/poly_hermite.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/tr1/poly_laguerre.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/lib/gcc/arm-none-eabi/7.2.1/include/stdarg.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/sys/_sigset.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/gthr-default.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/atomic_word.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/cxxabi_forced.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/backward/binders.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/string_view.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/locale_classes.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/streambuf.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/ctype_base.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/ctype_inline.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/locale_facets.tcc","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/basic_ios.tcc","c:/users/udit6/desktop/vex/v5tester/include/rtos/projdefs.h","c:/users/udit6/desktop/vex/v5tester/include/rtos/portmacro.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/lib/gcc/arm-none-eabi/7.2.1/include/stdbool.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/_newlib_version.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/os_defines.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/arm-none-eabi/thumb/v7-ar/fpv3/softfp/bits/cpu_defines.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/machine/ieeefp.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/machine/stdlib.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/bits/exception_defines.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/c++/7.2.1/debug/assertions.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/machine/_endian.h","c:/users/udit6/appdata/local/programs/pros/toolchain/usr/arm-none-eabi/include/machine/types.h","c:/users/udit6/desktop/vex/v5tester/include/pros/colors.h","c:/users/udit6/desktop/vex/v5tester/include/display/lv_conf.h"],"skipped_by_preprocessor":[],"types":[{"id":0,"usr":2,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":[]},{"id":1,"usr":5339145444342637432,"detailed_name":"stream_buf_t","short_name_offset":0,"short_name_size":12,"kind":252,"hover":"typedef void * stream_buf_t","comments":"\nType by which stream buffers are referenced.  For example, a call to\nstream_buf_create() returns an stream_buf_t variable that can\nthen be used as a parameter to stream_buf_send(), stream_buf_recv(),\netc.","declarations":[],"spell":"64:16-64:28|-1|1|2","extent":"64:1-64:28|-1|1|0","alias_of":0,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["64:16-64:28|-1|1|4","307:25-307:37|-1|1|4","408:34-408:46|-1|1|4","497:25-497:37|-1|1|4","583:37-583:49|-1|1|4","608:27-608:39|-1|1|4","628:29-628:41|-1|1|4","648:30-648:42|-1|1|4","671:27-671:39|-1|1|4","692:31-692:43|-1|1|4","713:29-713:41|-1|1|4","750:33-750:45|-1|1|4","789:44-789:56|-1|1|4","829:47-829:59|-1|1|4","832:1-832:13|-1|1|4","836:1-836:13|-1|1|4","843:43-843:55|-1|1|4","844:48-844:60|-1|1|4","845:45-845:57|-1|1|4"]},{"id":2,"usr":5778908825573379114,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["307:1-307:7|-1|1|4","309:9-309:15|-1|1|4","408:1-408:7|-1|1|4","410:10-410:16|-1|1|4","497:1-497:7|-1|1|4","499:9-499:15|-1|1|4","583:1-583:7|-1|1|4","585:10-585:16|-1|1|4","692:1-692:7|-1|1|4","713:1-713:7|-1|1|4","750:61-750:67|-1|1|4","832:42-832:48|-1|1|4","833:14-833:20|-1|1|4","836:48-836:54|-1|1|4","837:17-837:23|-1|1|4"]},{"id":3,"usr":16199156163178427820,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["310:9-310:17|-1|1|4","500:9-500:17|-1|1|4","843:71-843:79|-1|1|4","844:2-844:10|-1|1|4"]},{"id":4,"usr":11353837028888530222,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["411:10-411:17|-1|1|4","586:10-586:17|-1|1|4","628:1-628:8|-1|1|4","648:1-648:8|-1|1|4","671:1-671:8|-1|1|4","750:1-750:8|-1|1|4","789:1-789:8|-1|1|4","789:72-789:79|-1|1|4","829:1-829:8|-1|1|4","829:75-829:82|-1|1|4","834:14-834:21|-1|1|4","838:17-838:24|-1|1|4"]},{"id":5,"usr":12339929197612516034,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["839:17-839:24|-1|1|4","845:2-845:9|-1|1|4"]},{"id":6,"usr":13236283931510162600,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["840:17-840:38|-1|1|4"]},{"id":7,"usr":13116059786805020697,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["844:2-844:10|-1|1|4"]}],"funcs":[{"id":0,"usr":2976919434097534995,"detailed_name":"size_t stream_buf_send(stream_buf_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, uint32_t xTicksToWait)","short_name_offset":7,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nsize_t stream_buf_send( stream_buf_t xStreamBuffer,\n                       const void *pvTxData,\n                       size_t xDataLengthBytes,\n                       uint32_t xTicksToWait );\npre>\n\nSends bytes to a stream buffer.  The bytes are copied into the stream buffer.\n\n***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer\nimplementation (so also the message buffer implementation, as message buffers\nare built on top of stream buffers) assumes there is only one task or\ninterrupt that will write to the buffer (the writer), and only one task or\ninterrupt that will read from the buffer (the reader).  It is safe for the\nwriter and reader to be different tasks or interrupts, but, unlike other\nFreeRTOS objects, it is not safe to have multiple different writers or\nmultiple different readers.  If there are to be multiple different writers\nthen the application writer must place each call to a writing API function\n(such as stream_buf_send()) inside a critical section and set the send\nblock time to 0.  Likewise, if there are to be multiple different readers\nthen the application writer must place each call to a reading API function\n(such as xStreamBufferRead()) inside a critical section and set the receive\nblock time to 0.\n\nUse stream_buf_send() to write to a stream buffer from a task.  Use\nxStreamBufferSendFromISR() to write to a stream buffer from an interrupt\nservice routine (ISR).\n\n@param xStreamBuffer The handle of the stream buffer to which a stream is\nbeing sent.\n\n@param pvTxData A pointer to the buffer that holds the bytes to be copied\ninto the stream buffer.\n\n@param xDataLengthBytes   The maximum number of bytes to copy from pvTxData\ninto the stream buffer.\n\n@param xTicksToWait The maximum amount of time the task should remain in the\nBlocked state to wait for enough space to become available in the stream\nbuffer, should the stream buffer contain too little space to hold the\nanother xDataLengthBytes bytes.  The block time is specified in tick periods,\nso the absolute time it represents is dependent on the tick frequency.  The\nmacro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds\ninto a time specified in ticks.  Setting xTicksToWait to portMAX_DELAY will\ncause the task to wait indefinitely (without timing out), provided\nINCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.  If a task times out\nbefore it can write all xDataLengthBytes into the buffer it will still write\nas many bytes as possible.  A task does not use any CPU time when it is in\nthe blocked state.\n\n@return The number of bytes written to the stream buffer.  If a task times\nout before it can write all xDataLengthBytes into the buffer it will still\nwrite as many bytes as possible.\n\nExample use:\npre>\nvoid vAFunction( stream_buf_t xStreamBuffer )\n{\nsize_t xBytesSent;\nuint8_t ucArrayToSend[] = { 0, 1, 2, 3 };\nchar *pcStringToSend = \"String to send\";\nconst uint32_t x100ms = pdMS_TO_TICKS( 100 );\n\n // Send an array to the stream buffer, blocking for a maximum of 100ms to\n // wait for enough space to be available in the stream buffer.\n xBytesSent = stream_buf_send( xStreamBuffer, ( void * ) ucArrayToSend, sizeof( ucArrayToSend ), x100ms );\n\n if( xBytesSent != sizeof( ucArrayToSend ) )\n {\n     // The call to stream_buf_send() times out before there was enough\n     // space in the buffer for the data to be written, but it did\n     // successfully write xBytesSent bytes.\n }\n\n // Send the string to the stream buffer.  Return immediately if there is not\n // enough space in the buffer.\n xBytesSent = stream_buf_send( xStreamBuffer, ( void * ) pcStringToSend, strlen( pcStringToSend ), 0 );\n\n if( xBytesSent != strlen( pcStringToSend ) )\n {\n     // The entire string could not be added to the stream buffer because\n     // there was not enough free space in the buffer, but xBytesSent bytes\n     // were sent.  Could try again to send the remaining bytes.\n }\n}\npre>\n\\defgroup stream_buf_send stream_buf_send\n\\ingroup StreamBufferManagement","declarations":[{"spell":"307:8-307:23|-1|1|1","param_spellings":["307:38-307:51","308:21-308:29","309:16-309:32","310:18-310:30"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":1,"usr":8589983131889909608,"detailed_name":"size_t xStreamBufferSendFromISR(stream_buf_t xStreamBuffer, const void *pvTxData, size_t xDataLengthBytes, int32_t *const pxHigherPriorityTaskWoken)","short_name_offset":7,"short_name_size":24,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nsize_t xStreamBufferSendFromISR( stream_buf_t xStreamBuffer,\n                              const void *pvTxData,\n                              size_t xDataLengthBytes,\n                              int32_t *pxHigherPriorityTaskWoken );\npre>\n\nInterrupt safe version of the API function that sends a stream of bytes to\nthe stream buffer.\n\n***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer\nimplementation (so also the message buffer implementation, as message buffers\nare built on top of stream buffers) assumes there is only one task or\ninterrupt that will write to the buffer (the writer), and only one task or\ninterrupt that will read from the buffer (the reader).  It is safe for the\nwriter and reader to be different tasks or interrupts, but, unlike other\nFreeRTOS objects, it is not safe to have multiple different writers or\nmultiple different readers.  If there are to be multiple different writers\nthen the application writer must place each call to a writing API function\n(such as stream_buf_send()) inside a critical section and set the send\nblock time to 0.  Likewise, if there are to be multiple different readers\nthen the application writer must place each call to a reading API function\n(such as xStreamBufferRead()) inside a critical section and set the receive\nblock time to 0.\n\nUse stream_buf_send() to write to a stream buffer from a task.  Use\nxStreamBufferSendFromISR() to write to a stream buffer from an interrupt\nservice routine (ISR).\n\n@param xStreamBuffer The handle of the stream buffer to which a stream is\nbeing sent.\n\n@param pvTxData A pointer to the data that is to be copied into the stream\nbuffer.\n\n@param xDataLengthBytes The maximum number of bytes to copy from pvTxData\ninto the stream buffer.\n\n@param pxHigherPriorityTaskWoken  It is possible that a stream buffer will\nhave a task blocked on it waiting for data.  Calling\nxStreamBufferSendFromISR() can make data available, and so cause a task that\nwas waiting for data to leave the Blocked state.  If calling\nxStreamBufferSendFromISR() causes a task to leave the Blocked state, and the\nunblocked task has a priority higher than the currently executing task (the\ntask that was interrupted), then, internally, xStreamBufferSendFromISR()\nwill set *pxHigherPriorityTaskWoken to pdTRUE.  If\nxStreamBufferSendFromISR() sets this value to pdTRUE, then normally a\ncontext switch should be performed before the interrupt is exited.  This will\nensure that the interrupt returns directly to the highest priority Ready\nstate task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it\nis passed into the function.  See the example code below for an example.\n\n@return The number of bytes actually written to the stream buffer, which will\nbe less than xDataLengthBytes if the stream buffer didn't have enough free\nspace for all the bytes to be written.\n\nExample use:\npre>\nA stream buffer that has already been created.\nstream_buf_t xStreamBuffer;\n\nvoid vAnInterruptServiceRoutine( void )\n{\nsize_t xBytesSent;\nchar *pcStringToSend = \"String to send\";\nint32_t xHigherPriorityTaskWoken = pdFALSE; // Initialised to pdFALSE.\n\n // Attempt to send the string to the stream buffer.\n xBytesSent = xStreamBufferSendFromISR( xStreamBuffer,\n                                        ( void * ) pcStringToSend,\n                                        strlen( pcStringToSend ),\n                                        &xHigherPriorityTaskWoken );\n\n if( xBytesSent != strlen( pcStringToSend ) )\n {\n     // There was not enough free space in the stream buffer for the entire\n     // string to be written, ut xBytesSent bytes were written.\n }\n\n // If xHigherPriorityTaskWoken was set to pdTRUE inside\n // xStreamBufferSendFromISR() then a task that has a priority above the\n // priority of the currently executing task was unblocked and a context\n // switch should be performed to ensure the ISR returns to the unblocked\n // task.  In most FreeRTOS ports this is done by simply passing\n // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the\n // variables value, and perform the context switch if necessary.  Check the\n // documentation for the port in use for port specific instructions.\n taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );\n}\npre>\n\\defgroup xStreamBufferSendFromISR xStreamBufferSendFromISR\n\\ingroup StreamBufferManagement","declarations":[{"spell":"408:8-408:32|-1|1|1","param_spellings":["408:47-408:60","409:22-409:30","410:17-410:33","411:26-411:51"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":2,"usr":17071282530650851615,"detailed_name":"size_t stream_buf_recv(stream_buf_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, uint32_t xTicksToWait)","short_name_offset":7,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nsize_t stream_buf_recv( stream_buf_t xStreamBuffer,\n                          void *pvRxData,\n                          size_t xBufferLengthBytes,\n                          uint32_t xTicksToWait );\npre>\n\nReceives bytes from a stream buffer.\n\n***NOTE***:  Uniquely among FreeRTOS objects, the stream buffer\nimplementation (so also the message buffer implementation, as message buffers\nare built on top of stream buffers) assumes there is only one task or\ninterrupt that will write to the buffer (the writer), and only one task or\ninterrupt that will read from the buffer (the reader).  It is safe for the\nwriter and reader to be different tasks or interrupts, but, unlike other\nFreeRTOS objects, it is not safe to have multiple different writers or\nmultiple different readers.  If there are to be multiple different writers\nthen the application writer must place each call to a writing API function\n(such as stream_buf_send()) inside a critical section and set the send\nblock time to 0.  Likewise, if there are to be multiple different readers\nthen the application writer must place each call to a reading API function\n(such as xStreamBufferRead()) inside a critical section and set the receive\nblock time to 0.\n\nUse stream_buf_recv() to read from a stream buffer from a task.  Use\nxStreamBufferReceiveFromISR() to read from a stream buffer from an\ninterrupt service routine (ISR).\n\n@param xStreamBuffer The handle of the stream buffer from which bytes are to\nbe received.\n\n@param pvRxData A pointer to the buffer into which the received bytes will be\ncopied.\n\n@param xBufferLengthBytes The length of the buffer pointed to by the\npvRxData parameter.  This sets the maximum number of bytes to receive in one\ncall.  stream_buf_recv will return as many bytes as possible up to a\nmaximum set by xBufferLengthBytes.\n\n@param xTicksToWait The maximum amount of time the task should remain in the\nBlocked state to wait for data to become available if the stream buffer is\nempty.  stream_buf_recv() will return immediately if xTicksToWait is\nzero.  The block time is specified in tick periods, so the absolute time it\nrepresents is dependent on the tick frequency.  The macro pdMS_TO_TICKS() can\nbe used to convert a time specified in milliseconds into a time specified in\nticks.  Setting xTicksToWait to portMAX_DELAY will cause the task to wait\nindefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1\nin FreeRTOSConfig.h.  A task does not use any CPU time when it is in the\nBlocked state.\n\n@return The number of bytes actually read from the stream buffer, which will\nbe less than xBufferLengthBytes if the call to stream_buf_recv() timed\nout before xBufferLengthBytes were available.\n\nExample use:\npre>\nvoid vAFunction( StreamBuffer_t xStreamBuffer )\n{\nuint8_t ucRxData[ 20 ];\nsize_t xReceivedBytes;\nconst uint32_t xBlockTime = pdMS_TO_TICKS( 20 );\n\n // Receive up to another sizeof( ucRxData ) bytes from the stream buffer.\n // Wait in the Blocked state (so not using any CPU processing time) for a\n // maximum of 100ms for the full sizeof( ucRxData ) number of bytes to be\n // available.\n xReceivedBytes = stream_buf_recv( xStreamBuffer,\n                                        ( void * ) ucRxData,\n                                        sizeof( ucRxData ),\n                                        xBlockTime );\n\n if( xReceivedBytes > 0 )\n {\n     // A ucRxData contains another xReceivedBytes bytes of data, which can\n     // be processed here....\n }\n}\npre>\n\\defgroup stream_buf_recv stream_buf_recv\n\\ingroup StreamBufferManagement","declarations":[{"spell":"497:8-497:23|-1|1|1","param_spellings":["497:38-497:51","498:15-498:23","499:16-499:34","500:18-500:30"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":3,"usr":11659225137733341969,"detailed_name":"size_t xStreamBufferReceiveFromISR(stream_buf_t xStreamBuffer, void *pvRxData, size_t xBufferLengthBytes, int32_t *const pxHigherPriorityTaskWoken)","short_name_offset":7,"short_name_size":27,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nsize_t xStreamBufferReceiveFromISR( stream_buf_t xStreamBuffer,\n                                 void *pvRxData,\n                                 size_t xBufferLengthBytes,\n                                 int32_t *pxHigherPriorityTaskWoken );\npre>\n\nAn interrupt safe version of the API function that receives bytes from a\nstream buffer.\n\nUse stream_buf_recv() to read bytes from a stream buffer from a task.\nUse xStreamBufferReceiveFromISR() to read bytes from a stream buffer from an\ninterrupt service routine (ISR).\n\n@param xStreamBuffer The handle of the stream buffer from which a stream\nis being received.\n\n@param pvRxData A pointer to the buffer into which the received bytes are\ncopied.\n\n@param xBufferLengthBytes The length of the buffer pointed to by the\npvRxData parameter.  This sets the maximum number of bytes to receive in one\ncall.  stream_buf_recv will return as many bytes as possible up to a\nmaximum set by xBufferLengthBytes.\n\n@param pxHigherPriorityTaskWoken  It is possible that a stream buffer will\nhave a task blocked on it waiting for space to become available.  Calling\nxStreamBufferReceiveFromISR() can make space available, and so cause a task\nthat is waiting for space to leave the Blocked state.  If calling\nxStreamBufferReceiveFromISR() causes a task to leave the Blocked state, and\nthe unblocked task has a priority higher than the currently executing task\n(the task that was interrupted), then, internally,\nxStreamBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE.\nIf xStreamBufferReceiveFromISR() sets this value to pdTRUE, then normally a\ncontext switch should be performed before the interrupt is exited.  That will\nensure the interrupt returns directly to the highest priority Ready state\ntask.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it is\npassed into the function.  See the code example below for an example.\n\n@return The number of bytes read from the stream buffer, if any.\n\nExample use:\npre>\nA stream buffer that has already been created.\nStreamBuffer_t xStreamBuffer;\n\nvoid vAnInterruptServiceRoutine( void )\n{\nuint8_t ucRxData[ 20 ];\nsize_t xReceivedBytes;\nint32_t xHigherPriorityTaskWoken = pdFALSE;  // Initialised to pdFALSE.\n\n // Receive the next stream from the stream buffer.\n xReceivedBytes = xStreamBufferReceiveFromISR( xStreamBuffer,\n                                               ( void * ) ucRxData,\n                                               sizeof( ucRxData ),\n                                               &xHigherPriorityTaskWoken );\n\n if( xReceivedBytes > 0 )\n {\n     // ucRxData contains xReceivedBytes read from the stream buffer.\n     // Process the stream here....\n }\n\n // If xHigherPriorityTaskWoken was set to pdTRUE inside\n // xStreamBufferReceiveFromISR() then a task that has a priority above the\n // priority of the currently executing task was unblocked and a context\n // switch should be performed to ensure the ISR returns to the unblocked\n // task.  In most FreeRTOS ports this is done by simply passing\n // xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the\n // variables value, and perform the context switch if necessary.  Check the\n // documentation for the port in use for port specific instructions.\n taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );\n}\npre>\n\\defgroup xStreamBufferReceiveFromISR xStreamBufferReceiveFromISR\n\\ingroup StreamBufferManagement","declarations":[{"spell":"583:8-583:35|-1|1|1","param_spellings":["583:50-583:63","584:16-584:24","585:17-585:35","586:26-586:51"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":4,"usr":17987463029089364033,"detailed_name":"void vStreamBufferDelete(stream_buf_t xStreamBuffer)","short_name_offset":5,"short_name_size":19,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nvoid vStreamBufferDelete( stream_buf_t xStreamBuffer );\npre>\n\nDeletes a stream buffer that was previously created using a call to\nstream_buf_create() or stream_buf_create_static().  If the stream\nbuffer was created using dynamic memory (that is, by stream_buf_create()),\nthen the allocated memory is freed.\n\nA stream buffer handle must not be used after the stream buffer has been\ndeleted.\n\n@param xStreamBuffer The handle of the stream buffer to be deleted.\n\n\\defgroup vStreamBufferDelete vStreamBufferDelete\n\\ingroup StreamBufferManagement","declarations":[{"spell":"608:6-608:25|-1|1|1","param_spellings":["608:40-608:53"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":5,"usr":17567145895319817967,"detailed_name":"int32_t stream_buf_is_full(stream_buf_t xStreamBuffer)","short_name_offset":8,"short_name_size":18,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nint32_t stream_buf_is_full( stream_buf_t xStreamBuffer );\npre>\n\nQueries a stream buffer to see if it is full.  A stream buffer is full if it\ndoes not have any free space, and therefore cannot accept any more data.\n\n@param xStreamBuffer The handle of the stream buffer being queried.\n\n@return If the stream buffer is full then pdTRUE is returned.  Otherwise\npdFALSE is returned.\n\n\\defgroup stream_buf_is_full stream_buf_is_full\n\\ingroup StreamBufferManagement","declarations":[{"spell":"628:9-628:27|-1|1|1","param_spellings":["628:42-628:55"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":6,"usr":6146202684295727229,"detailed_name":"int32_t stream_buf_is_empty(stream_buf_t xStreamBuffer)","short_name_offset":8,"short_name_size":19,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nint32_t stream_buf_is_empty( stream_buf_t xStreamBuffer );\npre>\n\nQueries a stream buffer to see if it is empty.  A stream buffer is empty if\nit does not contain any data.\n\n@param xStreamBuffer The handle of the stream buffer being queried.\n\n@return If the stream buffer is empty then pdTRUE is returned.  Otherwise\npdFALSE is returned.\n\n\\defgroup stream_buf_is_empty stream_buf_is_empty\n\\ingroup StreamBufferManagement","declarations":[{"spell":"648:9-648:28|-1|1|1","param_spellings":["648:43-648:56"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":7,"usr":3859997585677375802,"detailed_name":"int32_t stream_buf_reset(stream_buf_t xStreamBuffer)","short_name_offset":8,"short_name_size":16,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nint32_t stream_buf_reset( stream_buf_t xStreamBuffer );\npre>\n\nResets a stream buffer to its initial, empty, state.  Any data that was in\nthe stream buffer is discarded.  A stream buffer can only be reset if there\nare no tasks blocked waiting to either send to or receive from the stream\nbuffer.\n\n@param xStreamBuffer The handle of the stream buffer being reset.\n\n@return If the stream buffer is reset then pdPASS is returned.  If there was\na task blocked waiting to send to or read from the stream buffer then the\nstream buffer is not reset and pdFAIL is returned.\n\n\\defgroup stream_buf_reset stream_buf_reset\n\\ingroup StreamBufferManagement","declarations":[{"spell":"671:9-671:25|-1|1|1","param_spellings":["671:40-671:53"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":8,"usr":17187642208641080989,"detailed_name":"size_t stream_buf_get_unused(stream_buf_t xStreamBuffer)","short_name_offset":7,"short_name_size":21,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nsize_t stream_buf_get_unused( stream_buf_t xStreamBuffer );\npre>\n\nQueries a stream buffer to see how much free space it contains, which is\nequal to the amount of data that can be sent to the stream buffer before it\nis full.\n\n@param xStreamBuffer The handle of the stream buffer being queried.\n\n@return The number of bytes that can be written to the stream buffer before\nthe stream buffer would be full.\n\n\\defgroup stream_buf_get_unused stream_buf_get_unused\n\\ingroup StreamBufferManagement","declarations":[{"spell":"692:8-692:29|-1|1|1","param_spellings":["692:44-692:57"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":9,"usr":867830502987156556,"detailed_name":"size_t stream_buf_get_used(stream_buf_t xStreamBuffer)","short_name_offset":7,"short_name_size":19,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nsize_t stream_buf_get_used( stream_buf_t xStreamBuffer );\npre>\n\nQueries a stream buffer to see how much data it contains, which is equal to\nthe number of bytes that can be read from the stream buffer before the stream\nbuffer would be empty.\n\n@param xStreamBuffer The handle of the stream buffer being queried.\n\n@return The number of bytes that can be read from the stream buffer before\nthe stream buffer would be empty.\n\n\\defgroup stream_buf_get_used stream_buf_get_used\n\\ingroup StreamBufferManagement","declarations":[{"spell":"713:8-713:27|-1|1|1","param_spellings":["713:42-713:55"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":10,"usr":7129090840617416507,"detailed_name":"int32_t stream_buf_set_trigger(stream_buf_t xStreamBuffer, size_t xTriggerLevel)","short_name_offset":8,"short_name_size":22,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nint32_t stream_buf_set_trigger( stream_buf_t xStreamBuffer, size_t xTriggerLevel );\npre>\n\nA stream buffer's trigger level is the number of bytes that must be in the\nstream buffer before a task that is blocked on the stream buffer to\nwait for data is moved out of the blocked state.  For example, if a task is\nblocked on a read of an empty stream buffer that has a trigger level of 1\nthen the task will be unblocked when a single byte is written to the buffer\nor the task's block time expires.  As another example, if a task is blocked\non a read of an empty stream buffer that has a trigger level of 10 then the\ntask will not be unblocked until the stream buffer contains at least 10 bytes\nor the task's block time expires.  If a reading task's block time expires\nbefore the trigger level is reached then the task will still receive however\nmany bytes are actually available.  Setting a trigger level of 0 will result\nin a trigger level of 1 being used.  It is not valid to specify a trigger\nlevel that is greater than the buffer size.\n\nA trigger level is set when the stream buffer is created, and can be modified\nusing stream_buf_set_trigger().\n\n@param xStreamBuffer The handle of the stream buffer being updated.\n\n@param xTriggerLevel The new trigger level for the stream buffer.\n\n@return If xTriggerLevel was less than or equal to the stream buffer's length\nthen the trigger level will be updated and pdTRUE is returned.  Otherwise\npdFALSE is returned.\n\n\\defgroup stream_buf_set_trigger stream_buf_set_trigger\n\\ingroup StreamBufferManagement","declarations":[{"spell":"750:9-750:31|-1|1|1","param_spellings":["750:46-750:59","750:68-750:81"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":11,"usr":9229954333809932875,"detailed_name":"int32_t xStreamBufferSendCompletedFromISR(stream_buf_t xStreamBuffer, int32_t *pxHigherPriorityTaskWoken)","short_name_offset":8,"short_name_size":33,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nint32_t xStreamBufferSendCompletedFromISR( stream_buf_t xStreamBuffer, int32_t *pxHigherPriorityTaskWoken );\npre>\n\nFor advanced users only.\n\nThe sbSEND_COMPLETED() macro is called from within the FreeRTOS APIs when\ndata is sent to a message buffer or stream buffer.  If there was a task that\nwas blocked on the message or stream buffer waiting for data to arrive then\nthe sbSEND_COMPLETED() macro sends a notification to the task to remove it\nfrom the Blocked state.  xStreamBufferSendCompletedFromISR() does the same\nthing.  It is provided to enable application writers to implement their own\nversion of sbSEND_COMPLETED(), and MUST NOT BE USED AT ANY OTHER TIME.\n\nSee the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for\nadditional information.\n\n@param xStreamBuffer The handle of the stream buffer to which data was\nwritten.\n\n@param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be\ninitialised to pdFALSE before it is passed into\nxStreamBufferSendCompletedFromISR().  If calling\nxStreamBufferSendCompletedFromISR() removes a task from the Blocked state,\nand the task has a priority above the priority of the currently running task,\nthen *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a\ncontext switch should be performed before exiting the ISR.\n\n@return If a task was removed from the Blocked state then pdTRUE is returned.\nOtherwise pdFALSE is returned.\n\n\\defgroup xStreamBufferSendCompletedFromISR xStreamBufferSendCompletedFromISR\n\\ingroup StreamBufferManagement","declarations":[{"spell":"789:9-789:42|-1|1|1","param_spellings":["789:57-789:70","789:81-789:106"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":12,"usr":8558860645124908114,"detailed_name":"int32_t xStreamBufferReceiveCompletedFromISR(stream_buf_t xStreamBuffer, int32_t *pxHigherPriorityTaskWoken)","short_name_offset":8,"short_name_size":36,"kind":12,"storage":1,"hover":"","comments":"\nstream_buffer.h\n\npre>\nint32_t xStreamBufferReceiveCompletedFromISR( stream_buf_t xStreamBuffer, int32_t *pxHigherPriorityTaskWoken );\npre>\n\nFor advanced users only.\n\nThe sbRECEIVE_COMPLETED() macro is called from within the FreeRTOS APIs when\ndata is read out of a message buffer or stream buffer.  If there was a task\nthat was blocked on the message or stream buffer waiting for data to arrive\nthen the sbRECEIVE_COMPLETED() macro sends a notification to the task to\nremove it from the Blocked state.  xStreamBufferReceiveCompletedFromISR()\ndoes the same thing.  It is provided to enable application writers to\nimplement their own version of sbRECEIVE_COMPLETED(), and MUST NOT BE USED AT\nANY OTHER TIME.\n\nSee the example implemented in FreeRTOS/Demo/Minimal/MessageBufferAMP.c for\nadditional information.\n\n@param xStreamBuffer The handle of the stream buffer from which data was\nread.\n\n@param pxHigherPriorityTaskWoken *pxHigherPriorityTaskWoken should be\ninitialised to pdFALSE before it is passed into\nxStreamBufferReceiveCompletedFromISR().  If calling\nxStreamBufferReceiveCompletedFromISR() removes a task from the Blocked state,\nand the task has a priority above the priority of the currently running task,\nthen *pxHigherPriorityTaskWoken will get set to pdTRUE indicating that a\ncontext switch should be performed before exiting the ISR.\n\n@return If a task was removed from the Blocked state then pdTRUE is returned.\nOtherwise pdFALSE is returned.\n\n\\defgroup xStreamBufferReceiveCompletedFromISR xStreamBufferReceiveCompletedFromISR\n\\ingroup StreamBufferManagement","declarations":[{"spell":"829:9-829:45|-1|1|1","param_spellings":["829:60-829:73","829:84-829:109"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":13,"usr":4475072177517148545,"detailed_name":"stream_buf_t xStreamBufferGenericCreate(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, int32_t xIsMessageBuffer)","short_name_offset":13,"short_name_size":26,"kind":12,"storage":1,"hover":"","comments":"Functions below here are not part of the public API.","declarations":[{"spell":"832:14-832:40|-1|1|1","param_spellings":["832:49-832:65","833:21-833:39","834:22-834:38"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":14,"usr":4063196886187417823,"detailed_name":"stream_buf_t xStreamBufferGenericCreateStatic(size_t xBufferSizeBytes, size_t xTriggerLevelBytes, int32_t xIsMessageBuffer, uint8_t *const pucStreamBufferStorageArea, static_stream_buf_s_t *const pxStaticStreamBuffer)","short_name_offset":13,"short_name_size":32,"kind":12,"storage":1,"hover":"","comments":"","declarations":[{"spell":"836:14-836:46|-1|1|1","param_spellings":["836:55-836:71","837:24-837:42","838:25-838:41","839:33-839:59","840:47-840:67"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":15,"usr":4635623785096105307,"detailed_name":"void vStreamBufferSetStreamBufferNumber(stream_buf_t xStreamBuffer, uint32_t uxStreamBufferNumber)","short_name_offset":5,"short_name_size":34,"kind":12,"storage":1,"hover":"","comments":"","declarations":[{"spell":"843:7-843:41|-1|1|1","param_spellings":["843:56-843:69","843:80-843:100"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":16,"usr":17469390157195280554,"detailed_name":"uint32_t uxStreamBufferGetStreamBufferNumber(stream_buf_t xStreamBuffer)","short_name_offset":9,"short_name_size":35,"kind":12,"storage":1,"hover":"","comments":"","declarations":[{"spell":"844:11-844:46|-1|1|1","param_spellings":["844:61-844:74"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":17,"usr":12495262566957169136,"detailed_name":"uint8_t ucStreamBufferGetStreamBufferType(stream_buf_t xStreamBuffer)","short_name_offset":8,"short_name_size":33,"kind":12,"storage":1,"hover":"","comments":"","declarations":[{"spell":"845:10-845:43|-1|1|1","param_spellings":["845:58-845:71"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]}],"vars":[{"id":0,"usr":12002312352762511025,"detailed_name":"STREAM_BUFFER_H","short_name_offset":0,"short_name_size":15,"hover":"#define STREAM_BUFFER_H","comments":"","declarations":[],"spell":"52:9-52:24|-1|1|2","extent":"52:9-52:24|-1|1|0","uses":[],"kind":255,"storage":0},{"id":1,"usr":6899744554554580474,"detailed_name":"","short_name_offset":0,"short_name_size":0,"hover":"","comments":"","declarations":[],"uses":["54:14-54:25|-1|1|4","848:14-848:25|-1|1|4"],"kind":0,"storage":0},{"id":2,"usr":2035361373851777872,"detailed_name":"stream_buf_create","short_name_offset":0,"short_name_size":17,"hover":"#define stream_buf_create( xBufferSizeBytes, xTriggerLevelBytes ) xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE )","comments":"","declarations":[],"spell":"132:9-132:26|-1|1|2","extent":"132:9-132:142|-1|1|0","uses":[],"kind":255,"storage":0},{"id":3,"usr":18202837553328698362,"detailed_name":"stream_buf_create_static","short_name_offset":0,"short_name_size":24,"hover":"#define stream_buf_create_static( xBufferSizeBytes, xTriggerLevelBytes, pucStreamBufferStorageArea, pxStaticStreamBuffer ) xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, pdFALSE, pucStreamBufferStorageArea, pxStaticStreamBuffer )","comments":"","declarations":[],"spell":"213:9-213:33|-1|1|2","extent":"213:9-213:255|-1|1|0","uses":[],"kind":255,"storage":0},{"id":4,"usr":17867914055727998688,"detailed_name":"","short_name_offset":0,"short_name_size":0,"hover":"","comments":"","declarations":[],"uses":["842:6-842:30|-1|1|4"],"kind":0,"storage":0}]}